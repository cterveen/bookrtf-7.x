<?php
 
 /**
 * @file
 * A  module that exports books as rtf
 */
 
 /**
 * Load the PHP simple HTML DOM parser if not done yet
 *
 * get it here: https://simplehtmldom.sourceforge.io/
 * save it to: sites/all/libraries/simle_html_dom/
 */ 
include_once("sites/all/libraries/simple_html_dom/simple_html_dom.php");

 /**
 * Load a css-parser if not done yet
 *
 * get it here: https://github.com/Schepp/CSS-Parser
 * save it to: sites/all/libraries/schepp-css-parser/
 */ 
include_once("sites/all/libraries/schepp-css-parser/parser.php");
 
 /**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path 
 *   Which path of the site we're using to display help
 * @param arg 
 *   Array that holds the current path as returned from arg() function
 */
 
function bookrtf_help($path, $arg) {
  switch ($path) {
    case "admin/help#bookrtf":
      return '' . t("Exports a book as rtf file.") . '';
      break;
  }
}

/**
* Implements hook_menu().
*/

function bookrtf_menu() {
  $items = array();
  $items['book/rtf/1'] = array(
     'title' => 'Download',
     'page callback' => '_bookrtf_page',
     'page arguments' => array(2),
     'access arguments' => array('access content'),
     'type' => MENU_CALLBACK,
   );
   
   $items['admin/config/bookrtf'] = array(
    'title' => 'BookRTF',
    'description' => 'Configuration for BookRTF module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookrtf_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM);
   
   
   return $items;
}


/** 
 * Implements hook_form
 */

function bookrtf_form($form, &$form_state) {

  /**
  * Options for the module (need a lot of that)
  *
  * - Custom title
  * - Custom filename
  * - Custom front_page
  * - Show table of contents
  * - Show index
  * - Download page text.
  */
  
  $form['bookrtf_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Book title'),
    '#default_value' => variable_get('bookrtf_title', variable_get('site_name', "Default site name")),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The title to use for the book'),
    '#required' => TRUE,
  );
  
  $form['bookrtf_filename'] = array(
    '#type' => 'textfield',
    '#title' => t('File name'),
    '#default_value' => variable_get('bookrtf_filename', "download.rtf"),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The filename for the download'),
    '#required' => FALSE,
  );
  
  $form['bookrtf_flyleaf'] = array (
    '#type' => 'checkbox',
    '#title' => 'Include flyleaf',
    '#default_value' => variable_get('bookrtf_flyleaf', 1));
  
  $form['bookrtf_toc'] = array (
    '#type' => 'checkbox',
    '#title' => 'Include table of contents',
    '#default_value' => variable_get('bookrtf_toc', 1));
    
  $form['bookrtf_index'] = array(
    '#type' => 'checkbox',
    '#title' => 'Include index',
    '#default_value' => variable_get('bookrtf_index', 0));
    
  $bookrtf_front_page = variable_get('bookrtf_front_page', array('value' => '<h3>'.variable_get('bookrtf_title', variable_get('site_name', "Default site name")).'</h3>', 'format' => 'full_html'));
  
  $form['bookrtf_front_page'] = array(
    '#type' => 'text_format',
    '#format' => $bookrtf_front_page['format'],
    '#title' => 'Custom frontpage',
    '#default_value' => $bookrtf_front_page['value'],
    '#description' => t('A custom frontpage for your book'));
    
  $form['bookrtf_download_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title of download page'),
    '#default_value' => variable_get('bookrtf_download_title', "Download"),
    '#size' => 20,
    '#maxlength' => 20,
    '#description' => t('The title to use for the download page'),
    '#required' => TRUE,
  );    
    
  $bookrtf_download_page = variable_get('bookrtf_download_page', array('value' => '<p><a href = "' . file_create_url('public://' . variable_get('bookrtf_filename', "download.rtf")) . '">Download ' . variable_get('bookrtf_filename', "download.rtf") . '</p>', 'format' => 'full_html'));
  $form['bookrtf_download_page'] = array(
    '#type' => 'text_format',
    '#format' => $bookrtf_download_page['format'],
    '#title' => t('Contents of download page'),
    '#default_value' => $bookrtf_download_page['value'],
    '#description' => t('The text of the download page'),
    '#required' => TRUE);

  return system_settings_form($form);
}

/**
 * Implements validation from the Form API.
 * 
 * @param $form
 *   A structured array containing the elements and properties of the form.
 * @param $form_state
 *   An array that stores information about the form's current state 
 *   during processing.
 */
function bookrtf_form_validate($form, &$form_state){
  $filename = $form_state['values']['bookrtf_filename'];
  if (strlen($filename) <= 4 | substr($filename, -4) != ".rtf") {
    form_set_error('bookrtf_filename', t('You must enter a valid filename that ends with .rtf'));
  }
}


 /**
 * Get the contents from print and, convert to RTF, save as file and show a download page.
 */

function _bookrtf_page($nid) {
  if (user_access('access content')) {
    $node = node_load($nid);
    if (isset($node->book)) {
      
      global $base_url;
      $tree = book_menu_subtree_data($node->book);        
      $content = bookrtf_index_traverse($tree);
      
      $file = file_destination("public://" . variable_get('bookrtf_filename', "download.rtf"), FILE_EXISTS_REPLACE);
      $url_rtf = file_create_url("public://" . variable_get('bookrtf_filename', "download.rtf"));
      $url_pdf = file_create_url("public://gele-boekje.pdf");
      
      $content = bookrtf_convert($content, $base_url);
      
      file_put_contents($file, $content);
      
      $bookrtf_download_page = variable_get('bookrtf_download_page', array('value' => '<p><a href = "' . file_create_url('public://' . variable_get('bookrtf_filename', "download.rtf")) . '">Download ' . variable_get('bookrtf_filename', "download.rtf") . '</p>', 'format' => 'full_html'));
      
      $page_array['index'] = array(
        '#title' => t(variable_get('bookrtf_download_title', "Download")),
        '#markup' => t($bookrtf_download_page['value']),
      );
   
      return $page_array;
    }
    else {
      drupal_not_found();
    }
  }
  else {
    drupal_access_denied();
  }  
}

 /**
 * Copy of book_index_traverse
 */

function bookrtf_index_traverse($tree) {
    $output = '';    
    
    foreach ($tree as $data) {
      // Note- access checking is already performed when building the tree.
      if ($node = node_load($data['link']['nid'], FALSE)) {
        $children = '';

        if ($data['below']) {
          $children = bookrtf_index_traverse($data['below']);
        }
      }
      
      $output .= book_node_export($node, $children);      
      
    }
    
    return $output;  
}

 /**
 * The engine, convert HTML output to RTF and add some shiny touches.
 */

function bookrtf_convert($content, $base_url) {
  // put some html tags around it so we can push it into the html converter.
  $content = "<html><body>" . $content . "</body></html>";
  
  // CLEAN UP spaces after newlines.
  $content = preg_replace("|\s+([\r\n]+)\s+|", "$1", $content);
  
  $fonttbl = array();
  // default style
  global $rtf_style;
  $rtf_style = array(
    "body" => "\\sa200\\qc ",
    "h1" => "\\sa200\\fs32\\b ",
    "h2" => "\\sa0\\fs16\\b ",
    "h3" => "\\sa0\\qc\\fs32\\b ");
    
  // get the stylesheet
  // TODO look for it in the theme directory!
  $css_file = "sites/all/modules/bookrtf/rtf.css";
  if (is_file($css_file)) {
    $css_parser = new CssParser();
    $css_parser->load_files($css_file);
    $css_parser->parse();
    $css = $css_parser->parsed;
  }
    
  // apply
  $tags = array_keys($css["main"]);
  // clear
  foreach ($tags as $tag) {
    $rtf_style[$tag] = "";
  }
  // build
  foreach ($tags as $tag) {
    if (array_key_exists("margin-bottom", $css["main"][$tag])) {
      $rtf_style[$tag] .= "\\sa". bookrtf_converter($css["main"][$tag]["margin-bottom"], "twips", 0);
    }
    if (array_key_exists("text-align", $css["main"][$tag])) {
      // default is left so skip that
      switch(trim($css["main"][$tag]["text-align"])) {
        case "center":
          $rtf_style[$tag] .= "\\qc";
          break;
        case "justify":
          $rtf_style[$tag] .= "\\gj";
          break;
        case "right":
          $rtf_style[$tag] .= "\\qr";
          break;
      }
    }
    if (array_key_exists("font-family", $css["main"][$tag])) {
      $r = array();
      // In css a family of fonts is given, if the first is not available the second is tried etc.
      // I'm not sure how rtf / word processors handle that. Just pick the first one and hope for the best.
      // TODO: first font found is the default font; that's not a problem if body is the first tag and
      //       font-family is defined there. It is otherwise.
      preg_match("|^([^;]+);?|", $css["main"][$tag]["font-family"], $r);
      $font = trim($r[1]);
      $font = preg_replace("|\"|", "", $font);
      if (!array_key_exists($font, $fonttbl)) {
        $fonttbl[$font] = count($fonttbl);
      }
      $rtf_style[$tag] .= "\\f" . $fonttbl[$font];
    }
    if (array_key_exists("font-size", $css["main"][$tag])) {
      $rtf_style[$tag] .= "\\fs". bookrtf_converter($css["main"][$tag]["font-size"], "half points", 24);
    }
    if (array_key_exists("font-weight", $css["main"][$tag])) {
      switch(trim($css["main"][$tag]["font-weight"])) {
        case "bold":
          $rtf_style[$tag] .= "\\b";
          break;
      }
    }
    $rtf_style[$tag] .= " ";
  }
  
  // Setup the parser
  $html = str_get_html($content);
  
  $book_title = variable_get('bookrtf_title', variable_get('site_name', "Default site name"));
    
  /**
   * HEADER
   * - Front page
   * - Flyleaf containing URL and date of download
   * - Table of contents
   * - Start of first page
   */   
   
  $header = "\\rtf1\\ansi\r\n";
  $header .= "\\deff0 {\\fonttbl ";
  foreach (array_keys($fonttbl) as $font) {
    $header .= "{\\f" . $fonttbl[$font] . " " . $font . ";}";
  }
  $header .= "}\r\n";
  $header .= "\\vertdoc\\paperh16834\\paperw11909\r\n";
  $header .= "\\fet0\\facingp\\ftnbj\\ftnrstpg\r\n";
  $header .= "\\plain\r\n";
  
  // preparing to make this a form element
  $bookrtf_front_page = variable_get('bookrtf_front_page', array('value' => '<h3>'.variable_get('bookrtf_title', variable_get('site_name', "Default site name")).'</h3>', 'format' => 'full_html'));
  $bookrtf_front_page["value"] = "<html><body><h3>" . $bookrtf_front_page["value"] . "</body></html>";
  $title_html = str_get_html($bookrtf_front_page["value"]);
  $elements = $title_html->find('html');
  bookrtf_traverse($elements, $base_url);
  $title_html = strip_tags($title_html);
  $header .= $title_html;

  // flyleaf
  $header .= "\\sect\r\n";
  
  if (variable_get('bookrtf_flyleaf', 1)) {
    $header .= "{\\pard\\qc";
    $header .= "{\\b " . $book_title . "}\\line\r\n";
    if (isset($base_url)) {
      $header .= $base_url;
    }
    $header .= "\\line\r\n\\line\r\n";
    $date = new DateTime();
    $header .= "Gegenereerd: " . date_format($date, "d-m-Y") . " \\par}";
  }
  $header .= "\\page\r\n";
  
  // table of contents
  if (variable_get('bookrtf_toc', 1)) {
    $header .= "{\\pard" .  $rtf_style["h1"] . "Inhoud\r\n";
    $header .= "\\par}\r\n{\\pard {";
        
    $toc = $html->find("h1");
    // remove the first title as this should be the title of the book and does not belong in the toc.
    $book_title_element = array_shift($toc);
    $book_title_element->outertext = "";
    foreach ($toc as $e) {
      // Assume title starts with the chapternumber
      $title = $e->innertext;
      preg_match("|^(\d+)\.\s|", $title, $match);
      $chapter = $match[1];
    
      $header .= "\\trowd";
      $header .= "\\cellx7000 \\cellx8309\r\n"; 
      $header .= "\\intbl\\pard " .$title . "\\cell";
      $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapter".$chapter."}}\\cell\\row\r\n";
    }
  
    if (variable_get('bookrtf_index', 0)) {
      $header .= "\\trowd";
      $header .= "\\cellx7000 \\cellx8309\r\n"; 
      $header .= "\\intbl\\pard Index\\cell";
      $header .= "\\qr{\\field{\*\\fldinst PAGEREF chapterIndex}}\\cell\\row\r\n";
    }
    $header .= "}\\par}\r\n";
  }
  
  /**
   *Footer
   * - index
   */
   
   $footer = "";
  
  if (variable_get('bookrtf_index', 0)) {
    $footer .= "\r\n\\page\r\n\\sect\r\n";
    $footer .= "{\\headerl\\pard\\ql {\b ".$book_title."}\\par}\r\n";
    $footer .= "{\\headerr\\pard\\qr Index\\par}\r\n";
    $footer .= "{\\footerr\\pard\\qr \\chpgn \\par}\r\n";
    $footer .= "{\\footerl\\pard\\ql \\chpgn \\par}\r\n";
    $footer .= "{\\pard " . $rtf_style["h1"];
    $footer .= "{\\*\\bkmkstart chapterIndex}{\\*\\bkmkend chapterIndex}Index";
    $footer .= "\\par}\r\n";
    $footer .= "\\sect \\sbknone \\cols2\r\n";  
  
    $anchors = $html->find('a[name]');
    $terms = array();
    foreach ($anchors as $a) {
      $label = $a->name;
      if (preg_match("|^index|", $label)) {
        $label = substr($label, 5);
        array_push($terms, $label);
      }
    }
    sort($terms);
  
    $cur_initial = "";
  
    global $index_id;
    $index_id = array();
    $i = 0;
  
    foreach ($terms as $t) {
      if (!isset($index_id[$t])) {
        $index_id[$t] = $i;
        $anchor = "index-" . $i ; 
        $i++;
  
        $initial = substr($t, 0, 1);
        if (is_numeric($initial)) {
          $initial = "#";
        }
        if ($initial != $cur_initial) {
          if ($cur_initial != "") {
            $footer .= "\\par}\r\n";
          }
          $footer .= "{\\pard\\fs28{\\b " . $initial . "\\b}\\par}\r\n";
          $footer .= "{\\pard\\ql ";
          $cur_initial = $initial;
        }
        $footer .= $t . " {\\field{\*\\fldinst PAGEREF ".$anchor."}}\\line\r\n";
      }
    }
    $footer .= "\\par}\r\n";
  }
  
  /** 
  * Start changing the content from HTML into RTF
  * The tough work is going to be done by bookrtf_traverse. 
  */
  $elements = $html->find('html');
  bookrtf_traverse($elements, $base_url);  
  
  // strip all remaining tags
  $html = strip_tags($html);
  
  // dumb the new code back to $content
  $content = $html;
  
  // FINAL DOCUMENT
  $content = "{" . $header . "\r\n" . $content . "\r\n" . $footer . "}";
  
  // the HTML parser adds some spaces which doesn't matter in HTML but does in RTF
  $content = preg_replace("|\s+([\r\n]+)\s+|", "$1", $content);
  $content = preg_replace("|\\intbl{\s+{|", "intbl{{", $content);
  
  // SPECIAL CHARACTERS
  // extended ascii
  $content = preg_replace("|€|", "\'80", $content);
  // $content = preg_replace("|foo|", "\'81", $content);
  $content = preg_replace("|‚|", "\'82", $content);
  $content = preg_replace("|ƒ|", "\'83", $content);
  $content = preg_replace("|„|", "\'84", $content);
  $content = preg_replace("|…|", "\'85", $content);
  $content = preg_replace("|†|", "\'86", $content);
  $content = preg_replace("|‡|", "\'87", $content);
  $content = preg_replace("|ˆ|", "\'88", $content);
  $content = preg_replace("|‰|", "\'89", $content);
  $content = preg_replace("|Š|", "\'8a", $content);
  $content = preg_replace("|‹|", "\'8b", $content);
  $content = preg_replace("|Œ|", "\'8c", $content);
  // $content = preg_replace("|foo|", "\'8d", $content);
  $content = preg_replace("|Ž|", "\'8e", $content);
  // $content = preg_replace("|foo|", "\'8f", $content);
  $content = preg_replace("|‘|", "\'91", $content);
  $content = preg_replace("|’|", "\'92", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|“|", "\'93", $content);
  $content = preg_replace("|”|", "\'94", $content);
  $content = preg_replace("|•|", "\'95", $content);
  $content = preg_replace("|–|", "\'96", $content);
  $content = preg_replace("|–|", "\'97", $content);
  $content = preg_replace("|˜|", "\'98", $content);
  $content = preg_replace("|™|", "\'99", $content);
  $content = preg_replace("|š|", "\'9a", $content);
  $content = preg_replace("|›|", "\'9b", $content);
  $content = preg_replace("|œ|", "\'9c", $content);
  // $content = preg_replace("|foo|", "\'9d", $content);
  $content = preg_replace("|ž|", "\'9e", $content);
  $content = preg_replace("|Ÿ|", "\'9f", $content);
  // $content = preg_replace("|foo|", "\'a0", $content);
  $content = preg_replace("|¡|", "\'a1", $content);
  $content = preg_replace("|¢|", "\'a2", $content);
  $content = preg_replace("|£|", "\'a3", $content);
  $content = preg_replace("|¤|", "\'a4", $content);
  $content = preg_replace("|¥|", "\'a5", $content);
  $content = preg_replace("|¦|", "\'a6", $content);
  $content = preg_replace("|§|", "\'a7", $content);
  $content = preg_replace("|¨|", "\'a8", $content);
  $content = preg_replace("|©|", "\'a9", $content);
  $content = preg_replace("|ª|", "\'aa", $content);
  $content = preg_replace("|«|", "\'ab", $content);
  $content = preg_replace("|¬|", "\'ac", $content);
  // $content = preg_replace("|foo|", "\'ad", $content); // Should be soft hyphen
  $content = preg_replace("|®|", "\'ae", $content);
  $content = preg_replace("|¯|", "\'af", $content);
  $content = preg_replace("|°|", "\'b0", $content);
  $content = preg_replace("|±|", "\'b1", $content);
  $content = preg_replace("|²|", "\'b2", $content);
  $content = preg_replace("|³|", "\'b3", $content);
  $content = preg_replace("|´|", "\'b4", $content);
  $content = preg_replace("|µ|", "\'b5", $content);
  $content = preg_replace("|¶|", "\'b6", $content);
  $content = preg_replace("|·|", "\'b7", $content);
  $content = preg_replace("|¸|", "\'b8", $content);
  $content = preg_replace("|¹|", "\'b9", $content);
  $content = preg_replace("|º|", "\'ba", $content);
  $content = preg_replace("|»|", "\'bb", $content);
  $content = preg_replace("|¼|", "\'bc", $content);
  $content = preg_replace("|½|", "\'bd", $content);
  $content = preg_replace("|¾|", "\'be", $content);
  $content = preg_replace("|¿|", "\'bf", $content);
  $content = preg_replace("|À|", "\'c0", $content);
  $content = preg_replace("|Á|", "\'c1", $content);
  $content = preg_replace("|Â|", "\'c2", $content);
  $content = preg_replace("|Ã|", "\'c3", $content);
  $content = preg_replace("|Ä|", "\'c4", $content);
  $content = preg_replace("|Å|", "\'c5", $content);
  $content = preg_replace("|Æ|", "\'c6", $content);
  $content = preg_replace("|Ç|", "\'c7", $content);
  $content = preg_replace("|È|", "\'c8", $content);
  $content = preg_replace("|É|", "\'c9", $content);
  $content = preg_replace("|Ê|", "\'ca", $content);
  $content = preg_replace("|Ë|", "\'cb", $content);
  $content = preg_replace("|Ì|", "\'cc", $content);
  $content = preg_replace("|Í|", "\'cd", $content);
  $content = preg_replace("|Î|", "\'ce", $content);
  $content = preg_replace("|Ï|", "\'cf", $content);
  $content = preg_replace("|Ð|", "\'d0", $content);
  $content = preg_replace("|Ñ|", "\'d1", $content);
  $content = preg_replace("|Ò|", "\'d2", $content);
  $content = preg_replace("|Ó|", "\'d3", $content);
  $content = preg_replace("|Ô|", "\'d4", $content);
  $content = preg_replace("|Õ|", "\'d5", $content);
  $content = preg_replace("|Ö|", "\'d6", $content);
  $content = preg_replace("|×|", "\'d7", $content);
  $content = preg_replace("|Ø|", "\'d8", $content);
  $content = preg_replace("|Ù|", "\'d9", $content);
  $content = preg_replace("|Ú|", "\'da", $content);
  $content = preg_replace("|Û|", "\'db", $content);
  $content = preg_replace("|Ü|", "\'dc", $content);
  $content = preg_replace("|Ý|", "\'dd", $content);
  $content = preg_replace("|Þ|", "\'de", $content);
  $content = preg_replace("|ß|", "\'df", $content);
  $content = preg_replace("|à|", "\'e0", $content);
  $content = preg_replace("|á|", "\'e1", $content);
  $content = preg_replace("|â|", "\'e2", $content);
  $content = preg_replace("|ã|", "\'e3", $content);
  $content = preg_replace("|ä|", "\'e4", $content);
  $content = preg_replace("|å|", "\'e5", $content);
  $content = preg_replace("|æ|", "\'e6", $content);
  $content = preg_replace("|ç|", "\'e7", $content);
  $content = preg_replace("|è|", "\'e8", $content);
  $content = preg_replace("|é|", "\'e9", $content);
  $content = preg_replace("|ê|", "\'ea", $content);
  $content = preg_replace("|ë|", "\'eb", $content);
  $content = preg_replace("|ì|", "\'ec", $content);
  $content = preg_replace("|í|", "\'ed", $content);
  $content = preg_replace("|î|", "\'ee", $content);
  $content = preg_replace("|ï|", "\'ef", $content);
  $content = preg_replace("|ð|", "\'f0", $content);
  $content = preg_replace("|ñ|", "\'f1", $content);
  $content = preg_replace("|ò|", "\'f2", $content);
  $content = preg_replace("|ó|", "\'f3", $content);
  $content = preg_replace("|ô|", "\'f4", $content);
  $content = preg_replace("|õ|", "\'f5", $content);
  $content = preg_replace("|ö|", "\'f6", $content);
  $content = preg_replace("|÷|", "\'f7", $content);
  $content = preg_replace("|ø|", "\'f8", $content);
  $content = preg_replace("|ù|", "\'f9", $content);
  $content = preg_replace("|ú|", "\'fa", $content);
  $content = preg_replace("|û|", "\'fb", $content);
  $content = preg_replace("|ü|", "\'fc", $content);
  $content = preg_replace("|ý|", "\'fd", $content);
  $content = preg_replace("|þ|", "\'fe", $content);
  $content = preg_replace("|ÿ|", "\'ff", $content);

  // html
  $content = preg_replace("|&amp;|", "&", $content);
  $content = preg_replace("|&deg;|", "\'b0", $content);
  $content = preg_replace("|&gt;|", ">", $content);
  $content = preg_replace("|&lt;|", "<", $content);
  $content = preg_replace("|&nbsp;|", " ", $content);
  $content = preg_replace("|&#039;|", "'", $content);

  // non breaking space
  $content = preg_replace("|\x{C2}\x{A0}|", " ", $content);

  return $content;
}

/**
 * HTML parsers may not spawn demons but if you use them to replace HTML tags
 * by RTF code they do attract gremlins as the parser gets in trouble with
 * nested tags (which occur a lot in HTML). Probably the parser is losing it's
 * structure. This is solved by going through the tree and start replacing tags
 * at the branches working up to the main stem.
 *
 * @param elements 
 *   the basic $elements from which to start
 * @param base_url 
 *   The base URL of the site, needed to convert links.
 */
 
function bookrtf_traverse ($elements, $base_url) {
  global $rtf_style;

  foreach ($elements as $e) {
    if ($e->first_child()) {
      $children = $e->children();
      bookrtf_traverse($children, $base_url);
    }
    
    // no children anymore --> start changing tags
    $tag = $e->tag;
    
    switch($tag) {
      case 'a':
        // this could be either external links or anchors
        if ($e->href) {
          // external link --> replace with footnote
          $url = $e->href;
          $title = $e->innertext;
          
          // no use to add a footnote if the link and label are the same
          if (preg_match("|^(https?://)?(mailto:)?" . $title . "/?$|", $url)) {
            $e->outertext = $title;
          }
          else {
            $e->outertext = $title . "{\\footnote \\pard {\\up6 \\chftn} " . $url . "}"; 
          }          
        }
        else if ($e->name) {
         if (preg_match("|^index|", $e->name)) {
           $label = substr($e->name, 5);
           global $index_id;
           $anchor = "index-" . $index_id[$label]; 
           $e->outertext = "{\\*\\bkmkstart ".$anchor."}{\\*\\bkmkend ".$anchor."}";
          }
        }
        break;
      case 'br':
        $e->outertext = "\\tab\\line\r\n";
        break;
      case 'h1':
        // start of a new chapter --> new page, right header contains chapter title, bookmark for the table of contents
        $title = $e->innertext;
                
        $rtf = "\\sect\\sftnrstpg\r\n";
        $rtf .= "{\\headerl\\pard\\ql {\\b " . variable_get('bookrtf_title', variable_get('site_name', "Default site name")) . "}\\par}\r\n";
        $rtf .= "{\\headerr\\pard\\qr " . $title . "}\r\n";
        $rtf .= "{\\footerr\\pard\\qr \\chpgn \\par}\r\n";
        $rtf .= "{\\footerl\\pard\\ql \\chpgn \\par}\r\n";
        // if the chapter starts with a number it should be in the index, add a bookmark for it
        if (preg_match("|^(\d+)\.\s|", $title, $match)) {
          $chapter = $match[1];
          $rtf .= "{\\*\\bkmkstart chapter".$chapter."}{\\*\\bkmkend chapter".$chapter."}\r\n";
        }
        $rtf .= "{\\pard" . $rtf_style["h1"] . $title . "\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'h2':
        $e->outertext = "{\\pard" . $rtf_style["h2"] . $e->innertext . "\\par}\r\n";
        break;
      case 'h3': 
        $e->outertext = "{\\pard" . $rtf_style["h3"] . $e->innertext . "\\par}\r\n";     
        break;
      case 'i': 
        $e->outertext = "{\\i " . $e->innertext . "}";
        break;
      case 'img':
        $url = $e->src;
        
        // assume relative url
        if (isset($base_url) & substr($url, 0, 4) != "http") {
          $url = $base_url . $url;
        }
        
        $string = file_get_contents($url);
        
        $img = imagecreatefromstring($string);
        
        $width = imagesx($img);
        $height = imagesy($img);
        $ratio = $width/$height;
        
        // asume full page width A4 - margins = 9028 - XX  = 8309 twips
        $picwidth = 8309;
        $picheight = round($picwidth / $ratio);
        $scalex = 100;
        $scaley = 100;

        $rtf = "{\\pard{\\pict\\picw".$width."\\pich".$height."\\picwgoal".$picwidth."\\pichgoal".$picheight."\\picscalex".$scalex."\\picscaley".$scaley;
    
        // set image type (jpg or png supported)
        if (substr($url, -4) == ".png") {
          $rtf .= "\pngblip\r\n";
        }
        else if (substr($url, -4) == ".jpg" or substr($url, -5) == ".jpeg") {
          $rtf .= "\jpegblip\r\n";
        }

        $hex = bin2hex($string);
        $hex = wordwrap($hex, 80, "\r\n", TRUE);
        
        $rtf .= $hex;
        $rtf .= "\r\n}\\par}\r\n";
        
        $e->outertext = $rtf;
        break;
      case 'li':
        /**
         * This might be a bit dirty but as I'm not going to make elaborate
         * list structures I feel confident working from li backwards and
         * strip out the list-tags later.
         */
         
        $level = 0;
        $type = "ul";
        $number = 1;
        $last = 1;
        
        // Type, level
        $p = $e->parent();
        while($p) {
          if ($p->tag == "ul" | $p->tag == "ol") {
            if ($level == 0) {
              $type = $p->tag;
            }
            $level++;
          }
          $p = $p->parent();
        }
        // Item number
        $s = $e->prev_sibling();
        while($s) {
          if ($s->tag == "li") {
            $number++;
          }
          $s = $s->prev_sibling();
        }
        // Last item?
        $s = $e->next_sibling();
        while($s) {
          if ($s->tag == "li") {
            $last = 0;
            break;
          }
          $s = $s->next_sibling();
        }
        
        $rtf = "";
        // if the first item of a nested list close the current paragraph.
        // TODO: might want to check if the list is inside a paragraph and do that anyway
        if ($level > 1 & $number == 1) {
          $rtf .= "\\par}\r\n";
        }
        $rtf .= "{\\pard";
        
        $firstindent = -360;
        $lineindent = 720 * $level;
        
        $rtf .= "\\fi" . $firstindent . "\\li". $lineindent;
        if ($type == "ul") {
          $rtf .= "\\bullet\\tab ";
        }
        else {
          $rtf .= " " . $array['id'] . ".\\tab ";
        }
        $rtf .= $e->innertext;
        
         // finish the paragraph unless it's the last item in a nested list
        // TODO this will give trouble if there's tekst after the nested list. This text will be included in the last item of the nested list at the moment.        
        if ($last != 1 | $level == 1) {
          $rtf .= "\\par}\r\n";
        }
        
        // if it's the last item of the list add some white space
        // TODO this creates an empty line, would be nicer if I could make that 200 twips height.
        if ($last == 1 & $level == 1) {
          $rtf .= "{\\pard\\sa0\\par}\r\n";
        }

        $e->outertext = $rtf;
        break;
      case 'p':
        $e->outertext = "{\\pard" . $rtf_style["body"] . $e->innertext . "\\par}\r\n";
        break;
      case 'strong': 
        $e->outertext = "{\\b " . $e->innertext . "}";
        break;
      case 'sub':
        $e->outertext = "{\\sub " . $e->innertext . "}";
        break;
      case 'sup': 
        $e->outertext = "{\\super " . $e->innertext . "}";
        break;
      case 'tbody':
        /**
         * Tables are a little bit more complicated than lists. I do not feel
         * confident working backwards from cells. Better to store the whole
         * table and than put it down again.
         */
         
        $width_in_twips = 8309;
        $width_in_pixels = 600;
        $num_rows = 0;
        $num_cols = 0;
        $table;
        $colwidth = array();        

        // retrieve table contents and some required specifications
        $rows = $e->children();
        foreach ($rows as $r) {
          if ($r->tag != "tr") {
            continue;
          }
          $num_rows++;
          $cells = $r->children();
          $cur_cols = 0;
          foreach ($cells as $c) {
            if ($c->tag != 'td' & $c->tag != 'th') {
              continue;
            }
            $cur_cols++;
            $table[$num_rows][$cur_cols]['innertext'] = $c->innertext;
            $table[$num_rows][$cur_cols]['col'] = $cur_cols;
            if ($c->colspan) {
              $table[$num_rows][$cur_cols]['colspan'] = $c->colspan;
            }
            else {
              $table[$num_rows][$cur_cols]['colspan'] = 1;
            }
            
            // Does using regexp for css also spawn demons?
            if ($c->style) {
              $style = array();
              preg_match_all("/([\w\-]+):\s([\w\s\-]+);?/", $c->style, $matches);
              
              for ($pid = 0; $pid < count($matches[0]); $pid++) {
                $style[$matches[1][$pid]] = $matches[2][$pid];
              }
              
              if(array_key_exists("width", $style)) {
                // asume width in pixels -> make percentage.
                if (substr($style['width'], -2) == "px") {
                  $width = substr($style['width'], 0, -2);
                  $colwidth[$cur_cols] = $width / $width_in_pixels;
                }                
              }
            }
            
            // correct cur_cols for colspan.
            $cur_cols += $table[$num_rows][$cur_cols]['colspan']-1;
          }
          if ($cur_cols > $num_cols) {
            $num_cols = $cur_cols;
          }
        }
        
        // some complicated stuff to calculate column widths
        $colright = array();
        $widthdefined = 0;
        $auto = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $widthdefined += $colwidth[$col];
          }
          else {
            $auto++;
          }
        }
        $autowidth = (1 - $widthdefined)/$auto;
        
        $colleft = 0;
        for ($col = 1; $col <= $num_cols; $col++) {
          if (array_key_exists($col, $colwidth)) {
            $colleft += $colwidth[$col];
          }
          else {
            $colleft += $autowidth;
          }
          $colright[$col] = $colleft;
        }
        
        // now we have the info start building it up again
        $rtf = "{";
        foreach ($table as $row) {
          $rtf .= "\\trowd";
          foreach ($row as $cell) {
            $rtf .= "\\cellx";
            $rtf .= floor($width_in_twips * $colright[$cell['col']+$cell['colspan']-1]);
          }
          foreach ($row as $cell) {
            $rtf .= "\\intbl{" . $cell['innertext'] . "}\\cell\r\n";
          }
          $rtf .= "\\row\r\n";
        }
        $rtf .= "}\r\n{\\pard\\par}\r\n";
          
        $e->outertext = $rtf;
        break;
      case 'title':
        $e->outertext = "";
        break;
      case 'u':
        $e->outertext = "{\\ul " . $e->innertext . "}";
    }    
  }
}

function bookrtf_converter($css, $rtf_units, $default) {
  $rtf_value = $default;
  
  preg_match("|(\d+)([a-zA-Z]+)|", $css, $r);
  $css_value = $r[1];
  $css_units = $r[2];
  
  // distance
  if ($css_units == "px" & $rtf_units == "twips") {
    $rtf_value = round($css_value / 96 * 1440);
  }
  
  // font size
  if ($css_units == "pt" & $rtf_units == "half points") {
    $rtf_value = $css_value * 2;
  }  
  
  return $rtf_value;
}
